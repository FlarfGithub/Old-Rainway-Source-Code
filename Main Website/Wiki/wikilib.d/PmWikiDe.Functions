version=pmwiki-2.2.118 ordered=1 urlencoded=1
author=MFWolff
charset=UTF-8
csum=(:notoc:)
ctime=1162888231
name=PmWikiDe.Functions
rev=59
targets=Cookbook.Functions,PmWikiDe.CustomMarkup,PmWikiDe.CustomActions,PmWikiDe.SecurityVariables,Cookbook.PccfToPcfOverride,PmWikiDe.LinkVariables,PmWikiDe.OtherVariables,PmWikiDe.EditVariables,PmWikiDe.UploadVariables,PmWikiDe.Functions,PmWikiDe.BasicVariables,PmWikiDe.Variables,PmWikiDe.Internationalizations,PmWikiDe.FmtPageName,PmWikiDe.MakeLink,PmWikiDe.ConditionalMarkup,PmWikiDe.Drafts,PmWikiDe.IncludeOtherPages,PmWikiDe.UpdatePage,Cookbook.MarkupExpressionSamples,Category.PmWikiDeveloper
text=(:title Funktionen:)%0a(:Summary: Beschreibung verschiedener innerer Funktionen und deren Arbeitsweise:)%0a(:Original_Page: PmWiki.{$Name}:)%0a(:Translation_Date: 2011-05-05:)%0a(:Translation_Status: %25green%25fertig%25%25:)%0a(:Audience: Administratoren (Fortgeschritten), Entwickler:)(:notoc:)%0a%0a>>rframe font-size:smaller clear:right%3c%3c%0a!! [[#contents]] Table of Contents%0a*[[#pmcrypt|pmcrypt()]]%0a*[[#pmsetcookie|pmsetcookie()]]%0a*[[#PCCF|PCCF()]] %25red%25(deprecated)%25%25%0a*[[#PPRA|PPRA()]]%0a*[[#PPRE|PPRE()]] %25red%25(deprecated)%25%25%0a*[[#Qualify|Qualify()]]%0a*[[#PHSC|PHSC()]]%0a*[[#PSS|PSS()]]%0a*[[#stripmagic|stripmagic()]]%0a*[[#FmtPageName|FmtPageName()]]%0a*[[#Markup|Markup()]]%0a*[[#MarkupToHTML|MarkupToHTML()]]%0a*[[#mkdirp|mkdirp()]]%0a*[[#MakeLink|MakeLink()]]%0a*[[#MakeUploadName|MakeUploadName()]]%0a*[[#SessionAuth|SessionAuth()]]%0a*[[#IsAuthorized|IsAuthorized()]]%0a*[[#CondAuth|CondAuth()]]%0a*[[#RetrieveAuthPage|RetrieveAuthPage()]]%0a*[[#RetrieveAuthSection|RetrieveAuthSection()]]%0a*[[#UpdatePage|UpdatePage()]]%0a>>%3c%3c%0a%0aDiese Seite erklärt einiges der inneren Arbeit von PmWiki, indem sie erklärt, wie einige der Funktionen in PmWiki arbeiten. Wegen einer kürzeren Liste/Übersicht, die zum Beispiel für Rezepteschreiber nützlich ist, siehe Cookbook:Functions. %0a%0aWenn Sie diese Funktionen nutzen, versichern Sie sich, dass alle relevanten internen Variablen korrekt initialisiert worden sind. Siehe [[Custom Markup|+]] und [[Custom Actions|+]] wegen weiterer Informationen darüber, wie diese Funktionen typischerweise von [@Markup()@] oder [@$HandleActions[]@] aufgerufen werden.%0a%0a!! [[#pmcrypt]] [@pmcrypt($password, $salt = null)@]%0aDie pmcrypt()-Funktion ist dazu gedacht, einen sicheren Ersatz für die [[http://php.net/crypt|PHP 5.6+ crypt()-Funktion]] zu bieten, wenn man kein $salt einsetzt, was sonst eine Warnmeldung (notice) hervorrufen würde. Wenn ein $salt angegeben wird, wird crypt() aufgerufen, um ein existierendes Passwort zu prüfen. Wenn ein $salt nicht angegeben wird, wird [[http://php.net/password_hash|password_hash()]] aufgerufen, um ein kryptografisch starkes Passwort zu erzeugen.%0a%0a!! [[#pmsetcookie]] [@pmsetcookie($name, $val="", $exp=0, $path="", $dom="", $secure=null, $httponly=null)@]%0aDiese Funktion ist gedacht als Ersatz für [[http://php.net/setcookie|setcookie()]]. Sie setzt die $secure- und $httponly-Argumente, wenn sie nicht von der aufrufenden Funktion gesetzt werden und wenn $EnableCookieSecure und $EnableCookieHTTPOnly aktiviert sind.%0a%0a!![[#PCCF]] [@PCCF($php_code, $callback_template='default', $callback_arguments = '$m')@] %25red%25 Missbilligt seit PHP 7.2%25%25%0aDie PCCF()-Funktion (''PmWiki Create Callback Function'') kann man einsetzen, um Callback-Funktionen zu erzeugen, die man mit [[(http://php.net/)preg_replace_callback]] einsetzt. Sie ist nötig für PHP 5.5., funktioniert aber auch bei früheren Versionen.%0a%0aDas erste Element ist der auszuwertende PHP-Kode.%0a%0aDas zweite Element (optional) ist die Callback-Vorlage, ein Schlüssel aus dem globalen $CallbackFnTemplates-Array. Es gibt zwei Vorlagen, die Rezepte-Autoren nutzen können%0a*'default' übergibt den $php_code als einen Funktionskode%0a*'return' packt $php_code als "return $php_code;" ein (seit PmWiki 2.2.62)%0a%0aDas dritte Argument (optional) ist das Argument der Callback-Funktion. Beachten Sie, dass PmWiki das '$m'-Argument heranzieht, um Übereinstimmungen mit regulären Ausdrücken zu übergeben, Ihre Funktion kann aber auch eigene Argumente benutzen.%0a%0aPCCF() erzeugt eine anonyme (Lambda-)Funktion, die den übergebenen Kode enthält, und lagert sie in einem Cache ein. Bei darauffolgenden Aufrufen mit demselben $php_code wird PCCF() den eingelagerten Funktionsnamen zurückgeben.%0a%0aSiehe http://php.net/create_function.%0a%0a>>font-style=italic%3c%3c%0aPHP 7.2 missbilligt create_function() und zukünftige Versionen werden die Funktion entfernen. Wenn Sie alten Kode übertragen müssen, der PCCF() benutzt hat, können Sie gewöhnlich reguläre Funktionen schreiben und den Funktionsnamen dort übergeben, wo Sie vorher das Ergebnis von PCCF() übergeben haben. Nehmen wir z.&nbsp;B. an, Sie haben ein Muster wie dieses:%0a    '/(?%3c=^| )([a-z])/' => PCCF("return strtoupper(\$m[1]);"),%0a%0aFür PHP_7.2-Kompatibilität können Sie eine Callback-Funktion schreiben:%0a    function %25green%25my_callback($m)%25%25 { return strtoupper($m[1]); }%0a%0aVerändern Sie dann noch das Muster, dass es so aussieht:%0a    '/(?%3c=^| )([a-z])/' => '%25green%25my_callback%25',%0a%0aSiehe auch: das Rezept [[(Cookbook:)PccfToPcfOverride]] erlaubt existierende Rezepte unter PHP 7 laufen zu lassen ohne "''deprecated create_function()''"-Meldungen zu verursachen.%0a>>%3c%3c%0a%0a!![[#PPRA]] [@PPRA($array_search_replace, $string)@]%0aDie PPRA()-Funktion (''PmWiki preg_replace array'') kann man einsetzen, um eine Ersetzung mit Hilfe eines regulären Ausdrucks mit oder ohne Auswertung durchzuführen, für PHP_5.5-Kompatibilität.%0a %0aSeit PmWiki 2.2.56 nutzt PmWiki diese Funktion, um die folgenden Arrays abzuarbeiten: $MakePageNamePatterns, $FmtP, $QualifyPatterns, $ROEPatterns, $ROSPatterns, $SaveAttrPatterns, $MakeUploadNamePatterns. Alle Benutzereinstellungen sollten weiterhin mit PHP_5.4 und früher funktionieren, aber Wikis, die mit PHP_5.5 laufen, brauchen ein paar Änderungen. %0a%0aDas erste Argument enthält die "suchen'=>'ersetzen'-Paare, das zweite ist der "haystack"-String, der manipuliert werden soll.%0a%0aDie 'replace'-Teile des Arrays können Strings oder Funktionsnamen sein. Wenn der 'replace'-Teil ein aufrufbarer Funktionsname ist, wird er via preg_replace_callback() mit dem Array der Übereinstimmungen als erstes Argument aufgerufen. Wenn er keine Funktion ist, wird ein einfacher preg_replace()-Aufruf durchgeführt. %0a%0aFrüher hat PmWiki solche Konstrukte benutzt:%0a  $fmt = preg_replace(array_keys($FmtP), array_values($FmtP), $fmt);%0a%0aJetzt ist es möglich, einfach dies zu benutzen:%0a  $fmt = PPRA($FmtP, $fmt);%0a%0aBeachten Sie, dass die Suchmuster seit PHP_5.5 kein /e-Flag (Evaluation, Auswertung) mehr haben können. Beim Erzeugen eines $array_search_replace-Arrays vor PHP_5.5 konnte man (z.&nbsp;B. für $MakePageNamePatterns) etwas einsetzen wie:%0a  '/(?%3c=^| )([a-z])/e' => "strtoupper('$1')",%0a%0aSeit PHP_5.5 sollte man dies einsetzen (funktioniert auch mit PHP_5.4 und früher):%0a  '/(?%3c=^| )([a-z])/' => PCCF("return strtoupper(\$m[1]);"),%0a%0aBeachten Sie, dass das /e-Flag jetzt weggelassen werden sollte, anstelle von '$0', '$1', '$2', sollte man  $m[0], $m[1], $m[2], etc. in dem Ersetzungskode einsetzen, und der Aufruf von PSS() im Ersetzungskode ist nicht nötig, da Backslashes nicht automatisch hinzugefügt werden. %0a%0a%0a!![[#PPRE]] [@PPRE($search_pattern, $replacement_code, $string)@] %25red%25 missbilligt seit PHP 7.2%25%25%0aDie PPRE()-Funktion (''PmWiki preg_replace evaluate'') kann eingesetzt werden, um eine reguläre Ausdruckersetzung mit Auswertung durchzuführen.%0a%0aSeit PHP_5.5 missbilligt die preg_replace()-Funktion das /e-Flag und zeigt Warnungen an, wenn es doch eingesetzt wird. Die PPRE()-Funktion erzeugt automatisch eine Callback-Funktion mit dem Ersetzungskode und ruft diese auf.%0a%0aVor PHP_5.5 konnte man solche Aufrufe nutzen:%0a  $fmt = preg_replace('/\\$([A-Z]\\w*Fmt)\\b/e','$GLOBALS["$1"]',$fmt);%0a%0aSeit PHP_5.5 kann man den vorhergehenden Kode-Schnipsel durch den folgenden ersetzen (funktioniert auch vor PHP 5.5):%0a  $fmt = PPRE('%25green%25/\\$([A-Z]\\w*Fmt)\\b/%25%25','$GLOBALS[$m[1]]',$fmt);%0a%0aBeachten Sie, dass das /e-Flag jetzt weggelassen werden sollte, anstelle von '$0', '$1', '$2', sollte man  $m[0], $m[1], $m[2], etc. in dem Ersetzungskode einsetzen, und der Aufruf von PSS() im Ersetzungskode ist nicht nötig, da kein automatisches Hinzufügen von Backslashes passiert. %0a%0a>>font-style=italic%3c%3c%0aIn PHP 7.2 und jünger ruft der Aufruf dieser Funktion eine "deprecated"-Notiz hervor. Sie sollten Ihren Kode neu schreiben für den Aufruf der Funktion [[(http://php.net/)preg_replace_callback]], indem Sie den Kode in eine richtige Funktion übertragen: %0a%0a  $fmt = preg_replace_callback('%25green%25/\\$([A-Z]\\w*Fmt)\\b/%25%25', 'my_global_var_callback',$fmt);%0a  function my_global_var_callback($m) { return $GLOBALS[$m[1]]; }%0a%0aAnstatt PCCF() zu benutzen, um eine anonyme Funktion zu erzeugen, fügen wir unserem Add-on eine reale Funktion hinzu und übergeben dann den Funktionsnamen als Muster-Ersetzung (siehe Beispiel bei [[#PCCF|PCCF]], das funktioniert auch mit PHP4 und 5):%0a  '/(?%3c=^| )([a-z])/' => '%25green%25my_callback%25%25',%0a>>%3c%3c%0a%0a!![[#Qualify]] [@Qualify($pagename, $text)@]%0aQualify() setzt $QualifyPatterns ein, um relative Verweise und Referenzen in absolute Entsprechungen umzuwandeln. %0aDiese Funktion wird von gewöhnlichen Markups aufgerufen, die Text aus anderen Seiten einfügen. Sie ersetzt Links wie [@[[Page]]@] durch [@[[Group/Page]]@] und Seiten(text)variablen wie [@{$Title}@] durch [@{Group.Page$Title}@], sodass sie in der Quellenseite und der einbettenden Seite gleichermaßen funktionieren. Siehe auch $QualifyPatterns und @@[[({$Name}#)RetrieveAuthSection]]()@@.%0a%0a!![[#PHSC]] [@PHSC($string_or_array, $flags=ENT_COMPAT, $encoding=null, $double_encode=true)@]%0aDie PHSC()-Funktion (''PmWiki HTML special characters'') ist ein Ersatz für die PHP-Funktion [[(http://php.net/)htmlspecialchars]].%0a%0aDie htmlspecialchars()-Funktion wurde ab PHP_5.4 in zweierlei Hinsicht verändert: sie benötigt nun einen gültigen String für die eingesetzte Zeichenkodierung und die voreingestellte Zeichenkodierung ist UTF-8. Dadurch können Abschnitte einer Seite auf vielen Sites, die ISO-8859-1 nutzen, leer sein, wenn das dritte Argument ($encoding) in htmlspecialchars() bei dessen Aufruf nicht gesetzt ist.%0a%0aDie PHSC()-Funktion ruft htmlspecialchars() mit einer 8-bit-Zeichenkodierung als drittes Argument auf, welche Zeichenkodierung das Wiki auch immer hat (es sei denn, Sie setzen explizit eine Zeichenkodierung). Auf diese Weise enthält der String niemals ungültige Zeichen.%0a%0aEs sollte für Entwickler sicher sein, wenn sie Aufrufe von htmlspecialchars() durch solche von PHSC() ersetzten. In PHSC() ist nur der erste Parameter obligatorisch, wenngleich Autoren dazu neigen könnten, PHSC($string_or_array, ENT_QUOTES) aufzurufen.%0a%0aAnders als htmlspecialchars() kann die PHSC()-Funktion Arrays iterativ bearbeiten, dabei werden nur die Werte verändert, nicht die Schlüssel des Arrays.%0a%0a!![[#PSS]] [@PSS($string)@]%0a%0aDie PSS()-Funktion (PmWiki Strip Slashes) entfernt die Backslashes, die automatisch durch die /e-Option von PHPs preg_replace()-Funktion vor Anführungszeichen gesetzt werden. PSS() wird am ehesten eingesetzt, um Argumente für Markup() zu ersetzen, wenn das Muster die /e-Option gesetzt hat und eines oder mehrere der eingeklammerten Musterteile Backslashes oder Anführungszeichen enthalten könnte.%0a%0a-->Von PM: PmWiki erwartet den Einsatz von PSS() immer innerhalb von Strings in doppelten Anführungszeichen, in deren Inneren wiederum einfach angeführte Strings enthalten sind. Der Grund dafür ist, dass wir nicht wollen, dass $1 oder $2 aus Versehen Zeichen enthalten, die dann zwischen den doppelten Anführungzeichen interpretiert werden, wenn PSS() durchgeführt wird. %0a--->@@Markup('foo', 'inline', '/(something)/e', 'Foo(PSS("$1"))');  # falsch@@%0a--->@@Markup('foo', 'inline', '/(something)/e', "Foo(PSS('$1'))");  # richtig@@%0a%0a%25note%25 Beachten Sie, die Extra-Schrägstriche werden nur von @@preg_replace@@ mit einem /e-Modifizierer hinzugefügt. Die Markup-Definition mit @@Markup_e()@@ braucht PSS() im Ersetzungsstring NICHT zu benutzen. Die Markup-Definitionen neuen Typs mit @@Markup()@@ und einem einfachen Funktionsna,en als Ersetzung brauchen @@PSS()@@ in der Ersetzungsfunktion NICHT zu benutzen. Löschen Sie die @@PSS()-@@Aufrufe, wenn Sie alte Markup-Regeln in das neue Format übertragen.%0a%0a!!! Beispiel%0a%0aDies ist ein fiktives Beispiel, bei dem PSS() eingesetzt werden sollte. Nehmen wir an, dass Sie eine Direktive (:example:) definieren wollen, sodass (:example "Ein Pferd":) diesen HTML-Kode ergibt:%0a->[@%3cdiv>"Ein Pferd"%3c/div>@].%0aUnd so könnte die Markup-Regel erzeugt werden:%0a-> [@%0aMarkup('example', 'directives',%0a       '/\\(:example\\s(.*?):\\)/e',%0a       "Keep('%3cdiv>'.PSS('$1').'%3c/div>')");%0a@]    %0aDer Einsatz von PSS() um '$1' ist nötig, weil der auf das Muster passende Text Anführungszeichen enthalten könnte und das /e Backslashes davorsetzen wird. %0a%0a%0a!![[#stripmagic]] [@stripmagic($string)@]%0a%0aDiese Funktion sollte eingesetzt werden beim Bearbeiten des Inhalts von [@$_POST@]- oder [@$_GET@]-Variablen, wenn diese Anführungszeichen oder Backslashes enthalten könnten. Sie prüft [@get_magic_quotes()@] und entfernt, beim Ergebnis ''wahr'', die automatisch eingefügten Escapes aus dem String.%0a%0aDiese Funktion kann Arrays rekursiv bearbeiten (nur die Werte werden bearbeitet).%0a%0a!![[#FmtPageName]] [@FmtPageName@]($fmt, $pagename)%0a%0a[[#FmtPageName-desc]]Gibt [@$fmt@] zurück, mit durchgeführter $variablen- und [=$[Internationalisierungs]=]-Ersetzung, mit der Vorgabe, dass die aktuelle Seite [@$pagename@] ist. Siehe unter den [[PmWikiDe/Variables|+]] nach einer (unvollständigen) Liste der verfügbaren Variablen, siehe auch nach in [[PmWikiDe/Internationalizations|+]] wegen der Internationalisierung. Sicherheit: Nicht anwenden bei vom Benutzer eingegebenen Daten.%0a%0aDas ist eine der wichtigsten Funktionen in PmWiki, siehe in [[PmWikiDe/FmtPageName|+]] wegen der vielen Details.%0a%0a%0a!![[#Markup]] [@Markup@]($name, $when, $pattern, $replace)%0a%0a[[#Markup-desc]]Fügt der Umwandlungstabelle ein neues Markup hinzu. Eine detailliertere Beschreibung finden Sie in [[PmWikiDe/CustomMarkup|+]].%0a%0aDiese Funktion wird verwendet, um Übersetzungsregeln in PmWikis Übersetzungs-'Maschine' einzufügen. Alle Argumente von Markup() sind Strings, und zwar %0a%0a:[@$name@]: Der String benennt die eingefügte Regel. Wenn es schon eine Regel mit diesem Namen gibt, wird diese Regel ignoriert.%0a:[@$when@]: Dieser String wird genutzt, um zu kontrollieren, wann eine Regel angewandt wird relativ zu anderen Regeln. Die Angabe "%3cxyz" bedeutet, wende diese Regel vor der Regel namens "xyz" an, während ">xyz" bedeutet, wende diese Regel nach der Regel namens "xyz" an. Siehe [[(PmWikiDe/CustomMarkup|+]] wegen weiterer Details bezüglich der Reihenfolge von Regeln. %0a:[@$pattern@]: Dieser String ist ein [[regulärer Ausdruck -> http://www.php.net/preg_replace]], der von der Übersetzungs-'Maschine' benutzt wird, um nach dem Auftreten dieser Regel in der Quelle für das Markup zu suchen. %0a:[@$replace@]: Dieser String wird den auf den regulären Ausdruck passenden Text ersetzen, wenn einer gefunden wurde.%0a%0aSiehe auch [[PmWikiDe/CustomMarkup|+]] und [[Cookbook:Functions#Markup]]%0a%0a%0a!![[#MarkupToHTML]] [@MarkupToHTML@]($pagename, $str)%0a%0a[[#MarkupToHTML-desc]] wandelt den String in [@$str@], der das Markup enthält, in den korrespondierenden HTML-Kode um, unter der Vorgabe, die aktuelle Seite sei [@$pagename@].%0a%0aSiehe auch: [[Cookbook:Functions#MarkupToHTML]]%0a%0a%0a!![[#mkdirp]] [@mkdirp@]($dir)%0a %0aDie Funktion [@mkdirp@]($dir) legt ein Verzeichnis $dir an, wenn es nicht schon existiert, einschließlich aller Elternverzeichnisse, die nötig sind. Für jedes erzeugte Verzeichnis wird geprüft, ob die Rechte für dies Verzeichnis ausreichen, damit PmWiki-Skripten daraus lesen und darin schreiben dürfen. Das schließt den Test auf Einschränkungen ein, die PHPs 'safe_mode'-Einstellungen bewirken. Wenn es [@mkdirp@]() nicht möglich ist, erfolgreich ein Schreib-/Lese-Verzeichnis anzulegen, bricht [@mkdirp@]() mit einer Fehlermeldung ab, die dem Administrator die Schritte anzeigt, entweder das Verzeichnis manuell anzulegen oder PmWiki genügend Rechte einzuräumen, dass es das selbst erledigen kann.%0a%0a%0a!![[#MakeLink]] [@MakeLink@]($pagename, $target, $txt, $suffix, $fmt)%0a%0aDie Funktion [@MakeLink@]($pagename, $target, $txt, $suffix, $fmt) gibt einen HTML-formatierten Anker-Verweis zurück. Ihre Argumente sind wie folgt:%0a $pagename ist die Quellseite%0a $target ist das Ziel des Verweises%0a $txt ist der Wert für '$LinkText' in der Ausgabe %0a $suffix ist ein Anhängsel, das an $txt angehängt wird %0a $fmt ist ein Formatstring, der zur Anwendung kommt%0a%0aWenn $txt NULL ist oder nicht angegeben ist, dann wird es automatisch aus $target bestimmt.%0a%0aWenn $fmt NULL ist oder nicht angegeben ist, dann verwendet MakeLink das Standardformat, das durch den Typ des Verweises gegeben ist. Für Seitenverweise sind das die $LinkPageExistsFmt und die $LinkPageCreateFmt-Variablen, für externe Verweise kommt es entweder vom $IMapLinkFmt-Array oder von $UrlLinkFmt. Innerhalb des Formatstrings wird $LinkUrl ersetzt durch den aufgelösten URL für den Verweis, $LinkText wird ersetzt durch den zugehörigen Text und $LinkAlt wird ersetzt durch alle "title"-Informationen (alternativer Text), die mit dem Verweise zusammenhängen.%0a%0aSiehe auch: [[PmWikiDe/MakeLink]] und [[Cookbook:Functions#MakeLink]]%0a%0a%0a!![[#MakeUploadName]] [@MakeUploadName@]($pagename, $x)%0a%0a@@MakeUploadName()@@ nimmt einfach einen String $x (den Namen eines Anhangs) und wandelt ihn in einen gültigen Namen um, indem alle unerwünschten Zeichen entfernt werden. Der Name soll mit einem alphanumerischen Zeichen beginnen und enden. Seit Version 2.0.beta28, wird die Dateierweiterung in Kleinbuchstaben umgewandelt. Diese Funktion ist in scripts/upload.php definiert und wird nur angewendet, wenn Hochladen von Dateien aktiviert ist.%0a%0a%0a!![[#SessionAuth]] [@SessionAuth@]($pagename, $auth=NULL)%0a%0a@@SessionAuth()@@ bewältigt die Aufrechterhaltung der Authentifikation mit Cookie-Sitzungen. Die Sitzung enthält ein Passwort oder eine überprüfte ID und verbundene Gruppen von vorherigen Aufrufen. Es fügt der Sitzung Elemente, die von @@$auth@@ übergeben werden, hinzu. Sie schreibt außerdem jedes Element, das in der Sitzung gesichert wurde, in @@$AuthPw@@ (Passwörter) und @@$AuthList@@ (IDs und Gruppen). %0a%0a%0a!![[#IsAuthorized]] [@IsAuthorized@]($chal, $source, &$from)%0a%0a@@IsAuthorized@@ nimmt einen Seitenattribute-String (z.&nbsp;B. "id:user1 $1$Ff3w34HASH...") in @@$chal@@ entgegen. @@$source@@ wird einfach zurückgegeben und wird gebraucht, um die Auth-Kaskade (Seitenattribute - Gruppenattribute - @@$DefaultPassword@@) aufzustellen. @@$from@@ wird zurückgegeben, wenn @@$chal@@ leer ist, weil es nicht vor dem Aufruf von @@IsAuthorized()@@ überprüft wird. Das ist nötig für die Auth-Kaskade. @@IsAuthorized()@@ gibt ein Array mit drei Werten zurück: @@$auth@@ @@1@@ - authenticated, @@0@@ - not authenticated, @@-1@@ - refused; @@$passwd@@; @@$source@@ von der Parameterliste.%0a%0a%0a!![[#CondAuth]] [@CondAuth@] ($pagename, 'auth level')%0a%0a[@CondAuth@] implementiert das  [[ConditionalMarkup]] für [@(:if auth level:)@]. Zum Beispiel ist [@CondAuth($pagename,'edit')@] wahr, wenn die Autorisierungsebene 'edit' ist. %0a%0aSie können entweder Autorisierungsebenen (@@'read', 'edit', 'attr', 'admin'@@) oder Aktionsnamen (@@'browse', 'upload', 'source'@@) als das zweite Argument von CondAuth() einsetzen. %0aBenutzen Sie die Funktion in Konfigurationsdateien, um Bedingungen mit einer Überprüfung der Autorisierungsebenen aufzustellen, ähnlich des Gebrauchs von  [@(:if auth level:)@] in Wiki-Seiten.%0a%0aAnmerkung: CondAuth() sollte aufgerufen werden, nachdem alle Autorisierungssebenen und Passwörter definiert worden sind. Wenn Sie sie mit [[PmWikiDe.Drafts]] benutzen, sollten Sie das draft.php-Skript einfügen bevor sie CondAuth() aufrufen:%0a[@%0a   $EnableDrafts = 1;%0a   $DefaultPasswords['publish'] = pmcrypt('secret');%0a   include_once("$FarmD/scripts/draft.php");%0a   if (! CondAuth($pagename, 'edit')) { /* was auch immer */ }%0a@]%0a%0aEs ist wichtig, sich zu erinnern, dass der beste Platz für den Aufruf von CondAuth() nahe dem Ende Ihres config.php-Skriptes ist. CondAuth() bevölkert den Cache (die Cashes), nachfolgende (Kochbuch-)Skripten könnten damit Schwierigkeiten haben, weil sie einen leeren Cache erwarten. Troubleshooting ist in einem solchen Fall eine schwierige Angelegenheit.%0a%0a%0a!! [[#RetrieveAuthPage]] @@RetrieveAuthPage($pagename, $level, $authprompt=true, $since=0)@@%0a%25comment%25 Pm words as said in http://article.gmane.org/gmane.comp.web.wiki.pmwiki.user/12493/match=retrieveauthpage%25%25%0amit:%0a%0a   $pagename   - Name der zu lesenden Seite%0a   $level      - erforderliche Autorisierungsebene (read/edit/auth/upload)%0a   $authprompt - wahr, wenn der Benutzer nötigenfalls zur Eingabe des Passwortes %0a                 aufgefordert werden sollte%0a   $since      - wieviel vom Seitenverlauf gelesen werden soll %0a                 0 == lies die komplette Seite einschließlich der ganzen Versionen ein%0a                 READPAGE_CURRENT == lies die Seite ein ohne die Versionen zu laden%0a                 timestamp == lies die Versionen nur zurück bis zum Zeitstempel ein%0a%0aDer $since Parameter erlaubt PmWiki, das Einlesen zu beenden, sobald es die benötigte Information hat &ndash; d.&nbsp;h., wenn eine Operation wie Browsen die Seitenversionen nicht braucht, kann die Angabe von READPAGE_CURRENT die Ladezeit merklich verkürzen. (Das kann insbesondere für so etwas wie Suchen und Seitenlisten wichtig sein.)%0a%0aWenden Sie zum Beispiel [@$page = @RetrieveAuthPage('Main.MyPage', 'read')@] an, um ein Seitenobjekt zu erhalten, das all die Informationen der korrespondierenden Datei in unterschiedlichen Schlüsseln enthält, [@$page['text']@] beispielsweise enthält einen String mit dem aktuellen Inhalt (wiki markup) von Main.MyPage. Dieser Gebrauch ist der alternativen Funktion [@ReadPage($pagename, $since=0)@] vorzuziehen, da sie die Autorisierung des Benutzers berücksichtigt, d.&nbsp;h. sie überprüft die Autorisierungsebene vorm Laden der Seite, jedenfalls kann sie so eingestellt werden. [@ReadPage()@] liest eine Seite ohne Rücksicht auf die Rechte ein.%0a%0aÜbergibt man 'ALWAYS' als Autorisierungsebene (statt 'read', 'edit', etc.), veranlasst das RetrieveAuthPage, die Seite auf jeden Fall zu lesen, sogar, wenn sie mit einem Lesepasswort geschützt ist.    %0a%0a%0a!! [[#RetrieveAuthSection]] @@RetrieveAuthSection($pagename, $pagesection, $list=NULL, $auth='read')@@%0aRetrieveAuthSection extrahiert einen Textabschnitt aus einer Seite. Wenn $pagesection mit etwas anderem als '#' beginnt, wird der Teil vor dem ersten '#' – oder bei dessen Fehlen, der gesamte Wert ~ als Angabe der gewünschten Herkunftsseite angesehen. Andernfalls sucht RetrieveAuthSection, sofern $list angegeben wurde, in den darin genannten Seiten (sollte ein Array sein). Falls keine dieser beiden Möglichkeiten eine Quellseite vorgegeben hat, wird $pagename als Quelle verwendet.%0a* Der Name der verwendeten Quellseite wird in der globalen Variablen $RASPageName gespeichert.%0a* Die aufrufende Funktion ist selbst verantwortlich dafür, ob und wie der beschaffte Text mittels Qualify() aufbereitet werden muss. Dies ist (nur) dann nötig, wenn Sie vorausbestimmen möchten, wie unqualifizierte Seiten- und Variablennamen aufgelöst werden sollen.%0a** Wenn sie so funktionieren sollen wie im Originaltext, wählen Sie die Quellseite als Bezugsseite für @@Qualify()@@.%0a** Wenn der importierte Text nicht als Wikitext gedacht ist, sondern als sonstige Auszeichnungssprache, in der Doppelpaare eckiger Klammern  vorkommen können, (:comment %3c-- nicht gemeint: Paare 〚doppelter eckiger Klammern〛 = U+301A/U+301B:) oder Dollarzeichen in geschweiften Klammern, dann sollte der Text nicht mittels @@Qualify()@@ angepasst werden. Wenn Sie den Text in einen Wikitext ausgeben wollen, müssen Sie ihn möglicherweise mittels @@Keep()@@ als "endgültig" verpacken lassen (im Falle von HTML-, RSS- oder sonstig XML-artiger Ausgabe: vorher @@PHSC()@@!), damit nachgelagerte Verarbeitungsschritte nicht auf die Idee kommen, sie müssten eine scheinbar vergessene @@Qualify()@@zierung nachholen.%0a** Wenn Ihr Kode Wikitext für eine Hilfsseite produziert, die von anderen Seiten in einem späteren Stadium der Einfügungskette einverleibt wird, benutzen Sie "GruppenName.SeitenName" der Hilfsseite als $pagename-Argument für @@Qualify()@@.%0a%0aDas bietet einen Weg, das von ReadPage zurückgegebene Array zu begrenzen, sodass es nur den Inhalt bis zu einer bestimmten Abschnittmarkierung herauszieht. Zum Beispiel, ziehe den Text zwischen dem Textbeginn und '##blogend' heraus:%0a->[@%0afunction FeedText($pagename, &$page, $tag) {%0a  $text = RetrieveAuthSection($pagename, '##blogend');%0a  $content = MarkupToHTML($pagename, $text);%0a  return "%3c$tag>%3c![CDATA[$content]]>%3c/$tag>";%0a}%0a@]%0a%0aDas '##blogend'-Argument heißt, lies vom Beginn der Seite bis genau vor der Zeile, die die Markierung enthält. %0aSiehe [[IncludeOtherPages|+]] wegen weiterer Informationen über die Abschnittspezifikationen.%0a %0aDiese Version liest keinen Text von Seiten, die lesegeschützt sind; wenn Sie Text auch von lesegeschützten Seiten haben wollen:%0a->[@%0a  $text = RetrieveAuthSection($pagename, '##blogend', NULL, 'ALWAYS');%0a@]%0a%0a%0a!! [[#UpdatePage]] @@UpdatePage($pagename, $old (page object), $new (page object));@@%0a''[[PmWikiDe/UpdatePage|weitere technische Anmerkungen]]''%0a%0a[@UpdatePage()@] erlaubt Kochbuchrezepten, das Verhalten des Bearbeitens einer Wikiseite mit dem Browser zu imitieren. %0aIntern macht PmWiki einige haushälterische Arbeiten, die über diese Funktion erreichbar sind (Erhalten der Verlaufs-(diff)-Information, Erhöhen der Seitenrevisionsnummer, Auffrischen der RecentChanges-Seiten, Senden von E-Mail-Benachrichtigungen etc. )%0a* "Page objekt" bezieht sich auf ein Array, das von [@ReadPage($pagename); @] zurückgegeben wurde. Anmerkung: $new['text'] sollte alle Seitendaten für die neue Version der Seite enthalten.%0a* Wenn eine Seite nicht existiert, wird UpdatePage() versuchen, sie anzulegen.%0a* Weglassen von $old (also [@UpdatePage($pagename, '', $new);@]) wird alle Seitenverlaufsdaten löschen &ndash; ein ''tabula rasa''.%0a@@UpdatePage()@@ kann nicht direkt von config.php aufgerufen werden, weil es notwendige Initialisierungen gibt, die erst später in pmwiki.php gemacht werden. Es reicht nicht, stdconfig.php zu laden. Wenn Sie @@UpdatePage()@@ nutzen wollen, müssen Sie es innerhalb einer [[PmWikiDe/CustomMarkup|eigenen Auszeichnung]], eines [[Cookbook:MarkupExpressionSamples|eigenen Markup-Ausdrucks]], oder einer [[PmWikiDe/CustomActions | benutzerdefinierten Aktion]] tun.%0a%0aCategories: [[!PmWiki Developer]]%0a%0a!!!Siehe auch %0a[[Cookbook.Functions]] [-auf englisch-]%0a
time=1567501816
title=Funktionen
